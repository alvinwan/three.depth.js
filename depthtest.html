<html>
    <head>
<style>
body {
    margin: 0;
  }
  #c {
    width: 100vw;
    height: 100vh;
    display: block;
  }
  #capture{
				position: absolute;
				left: 20px;
				top: 20px;
				padding: 10px;
				border: 1px solid white;
				z-index: 100;
				cursor: pointer;
				background-color: rgba( 0,0,0,.4);
			}
</style>
<script src="//cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://fake-vs-real-stereo.glitch.me/ocean.js"></script>
    <script src="js/CubemapToEquirectangular.js"></script>
    <script src="js/CubeOrthographicCamera.js"></script>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="capture" >Capture</div>

  <script>
    function main() {

      const canvas = document.querySelector('#c');
      const renderer = new THREE.WebGLRenderer({canvas});
      renderer.autoClearDepth = false;
      renderer.autoClearColor = false;
      
      const invisibleRenderTarget = new THREE.WebGLRenderTarget(1, 1);
      invisibleRenderTarget.depthTexture = new THREE.DepthTexture();

      const invisibleFov = 90;
      const invisibleAspect = 1;
      const invisibleNear = 0.1;
      const invisibleFar = 100;
      const invisibleCubeRenderTarget = new THREE.WebGLCubeRenderTarget(128);
      const invisibleCubeCamera = new THREE.CubeCamera(invisibleNear, invisibleFar, invisibleCubeRenderTarget)
      invisibleCubeCamera.position.z = 1;

      let canvasCameraIndex = 5; // index of camera to show in canvas
    
      const invisibleScene = new THREE.Scene();
      invisibleScene.background = new THREE.Color('white');
    
      // put the camera on a pole (parent it to an object)
      // so we can spin the pole to move the camera around the scene
      const cameraPole = new THREE.Object3D();
      invisibleScene.add(cameraPole);
      cameraPole.add(invisibleCubeCamera);
    
      {
        const color = 0xFFFFFF;
        const intensity = 1;
        const light = new THREE.DirectionalLight(color, intensity);
        light.position.set(-1, 2, 4);
        invisibleScene.add(light);
      }

      // Setup the actual scene. This is the scene we'll extract depth values of.
      function setupScene(scene) {
    
        const boxWidth = 1;
        const boxHeight = 1;
        const boxDepth = 1;
        const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
      
        function rand(min, max) {
          if (max === undefined) {
            max = min;
            min = 0;
          }
          return min + (max - min) * Math.random();
        }
      
        function randomColor() {
          return `hsl(${rand(360) | 0}, ${rand(50, 100) | 0}%, 50%)`;
        }
      
        const numObjects = 100;
        for (let i = 0; i < numObjects; ++i) {
          const material = new THREE.MeshPhongMaterial({
            color: randomColor(),
          });
      
          const cube = new THREE.Mesh(geometry, material);
          scene.add(cube);
      
          cube.position.set(rand(-20, 20), rand(-20, 20), rand(-20, 20));
          cube.rotation.set(rand(Math.PI), rand(Math.PI), 0);
          cube.scale.set(rand(3, 6), rand(3, 6), rand(3, 6));
        }
      }

      setupScene(invisibleScene);
    
      // depth render target will hold depth values from original scene in color channel
      // wont need the depth or stencil buffers for this color-only render target
      const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024, {
        depthBuffer: false,
        stenciBuffer: false,
      });
      const cubeCamera = new THREE.CubeOrthographicCamera(-1, 1, 1, -1, -1, 1, cubeRenderTarget);
      const equi = new CubemapToEquirectangular( renderer, false ); // Setup cubemap to equirectangular conversion

      const planeGeo = new THREE.PlaneBufferGeometry(2, 2);      
      const depthMaterial = new THREE.MeshBasicMaterial({
        map: invisibleRenderTarget.depthTexture,
      });
      depthMaterial.onBeforeCompile = function(shader) {
        // the <packing> GLSL chunk from three.js has the packDeathToRGBA function.
        // then at the end of the shader the default MaterialBasicShader has
        // already read from the material's `map` texture (the depthTexture)
        // which has depth in 'r' and assigned it to gl_FragColor
        shader.fragmentShader = shader.fragmentShader.replace(
            '#include <common>',
            '#include <common>\n#include <packing>',
        ).replace(
            '#include <fog_fragment>',
            'gl_FragColor = packDepthToRGBA( gl_FragColor.r );',
        );
      };  
    
      // Create 6 scenes, one for each face of the cubemap. Allows us to save depth
      // values one face at a time, by only rendering one face at a time.
      const depthScenes = [];
      for (let i = 0; i < 6; i++) {
        let depthScene = new THREE.Scene();
        const depthPlane = new THREE.Mesh(planeGeo, depthMaterial);
        depthScene.position.set(0, 0, -1);
        depthScene.add(depthPlane);
        depthScenes.push(depthScene);
      }
    
      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      function getCameras(cameraIndex) {
        // Select appropriate cameras given camera index
        let depthCamera = cubeCamera.children[cameraIndex]; // camera in depth space
        let invisibleCamera = invisibleCubeCamera.children[cameraIndex]; // camera in invisible space
        let depthScene = depthScenes[cameraIndex]; // scene to render depth into

        return {depthCamera, invisibleCamera, depthScene};
      }

      function renderDepthTo(renderTarget, cameraIndex = 6) {
        let {depthCamera, invisibleCamera, depthScene} = getCameras(cameraIndex);

        // draw render target scene to render target
        renderer.setRenderTarget(invisibleRenderTarget);
        renderer.clearDepth();
        renderer.render(invisibleScene, invisibleCamera);
        renderer.setRenderTarget(null);

        // set active cube face if the render target is a cube render target
        var activeCubeFace = renderTarget instanceof THREE.WebGLCubeRenderTarget ? cameraIndex : undefined;
        
        // render the depth texture to the provided target
        renderer.setRenderTarget(renderTarget, activeCubeFace);
        renderer.render(depthScene, depthCamera);
        renderer.setRenderTarget(null);
      }
    
      let depthValues = new Uint8Array(0);
      function render(time) {
        time *= 0.001;

        let {invisibleCamera, depthScene} = getCameras(canvasCameraIndex);
    
        if (resizeRendererToDisplaySize(renderer)) {
          const canvas = renderer.domElement;
          invisibleRenderTarget.setSize(canvas.width, canvas.height);
          // depthRenderTarget.setSize(canvas.width, canvas.height); // how to resize cube render target?
          invisibleCamera.aspect = canvas.clientWidth / canvas.clientHeight;
          invisibleCamera.updateProjectionMatrix();
        }
    
        cameraPole.rotation.y = time * .1;
        renderDepthTo(null, canvasCameraIndex); // use null to specify canvas
    
        requestAnimationFrame(render);
      }
    
      requestAnimationFrame(render);

      document.getElementById( 'capture' ).addEventListener( 'click', function( e ) {

          // render the depth texture to all faces of the cube, one at a time
          renderer.clearColor();
          for (let i = 0; i < 6; i++) {
            renderDepthTo(cubeRenderTarget, i, i);
          }

          // Unmanaged conversion. Do not use managed version since it will attempt a 
          // re-render. We previously manually rendered every cube face ourselves already.
          // This manual rendering, face by face, to save the depth values, is necessary,
          // since the *cube render target doesnt support depth textures.
          equi.convert( cubeCamera );
      });

      document.addEventListener('keydown', function(e) {
        if (e.keyCode >= 49 && e.keyCode < 55) {
          canvasCameraIndex = e.keyCode - 49;
        }
      });
    }
    
    main();
    </script>
</body>

</html>