<html>
    <head>
<style>
body {
    margin: 0;
  }
  #c {
    width: 100vw;
    height: 100vh;
    display: block;
  }
  #capture{
				position: absolute;
				left: 20px;
				top: 20px;
				padding: 10px;
				border: 1px solid white;
				z-index: 100;
				cursor: pointer;
				background-color: rgba( 0,0,0,.4);
			}
</style>
<script src="//cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://fake-vs-real-stereo.glitch.me/ocean.js"></script>
    <script src="js/CubemapToEquirectangular.js"></script>
    <script src="js/CubeOrthographicCamera.js"></script>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="capture" >Capture</div>

  <script>
    function main() {

      const canvas = document.querySelector('#c');
      const renderer = new THREE.WebGLRenderer({canvas});
      renderer.autoClearDepth = false;
      renderer.autoClearColor = false;
      
      const renderTarget = new THREE.WebGLRenderTarget(1, 1);
      renderTarget.depthTexture = new THREE.DepthTexture();
      // depth render target will hold depth values from original scene in color channel
      // wont need the depth or stencil buffers for this color-only render target
      const depthRenderTarget = new THREE.WebGLRenderTarget(1, 1, {
        depthBuffer: false,
        stenciBuffer: false,
      });

      const invisibleFov = 90;
      const invisibleAspect = 1;
      const invisibleNear = 0.1;
      const invisibleFar = 100;
      const invisibleCubeRenderTarget = new THREE.WebGLCubeRenderTarget(128);
      const invisibleCubeCamera = new THREE.CubeCamera(invisibleNear, invisibleFar, invisibleCubeRenderTarget)
      let invisibleCamera = invisibleCubeCamera.children[5];
      invisibleCubeCamera.position.z = 1;
    
      const invisibleScene = new THREE.Scene();
      invisibleScene.background = new THREE.Color('white');
    
      // put the camera on a pole (parent it to an object)
      // so we can spin the pole to move the camera around the scene
      const cameraPole = new THREE.Object3D();
      invisibleScene.add(cameraPole);
      cameraPole.add(invisibleCubeCamera);
    
      {
        const color = 0xFFFFFF;
        const intensity = 1;
        const light = new THREE.DirectionalLight(color, intensity);
        light.position.set(-1, 2, 4);
        invisibleCamera.add(light);
      }

      // Setup the actual scene. This is the scene we'll extract depth values of.
      function setupScene(scene) {
    
        const boxWidth = 1;
        const boxHeight = 1;
        const boxDepth = 1;
        const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
      
        function rand(min, max) {
          if (max === undefined) {
            max = min;
            min = 0;
          }
          return min + (max - min) * Math.random();
        }
      
        function randomColor() {
          return `hsl(${rand(360) | 0}, ${rand(50, 100) | 0}%, 50%)`;
        }
      
        const numObjects = 100;
        for (let i = 0; i < numObjects; ++i) {
          const material = new THREE.MeshPhongMaterial({
            color: randomColor(),
          });
      
          const cube = new THREE.Mesh(geometry, material);
          scene.add(cube);
      
          cube.position.set(rand(-20, 20), rand(-20, 20), rand(-20, 20));
          cube.rotation.set(rand(Math.PI), rand(Math.PI), 0);
          cube.scale.set(rand(3, 6), rand(3, 6), rand(3, 6));
        }
      }

      setupScene(invisibleScene);
    
      const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(128);
      const cubeCamera = new THREE.CubeOrthographicCamera(-1, 1, 1, -1, -1, 1, cubeRenderTarget);
      const equi = new CubemapToEquirectangular( renderer, false ); // Setup cubemap to equirectangular conversion

      const planeGeo = new THREE.PlaneBufferGeometry(2, 2);      
      const depthMaterial = new THREE.MeshBasicMaterial({
        map: renderTarget.depthTexture,
      });
      depthMaterial.onBeforeCompile = function(shader) {
        // the <packing> GLSL chunk from three.js has the packDeathToRGBA function.
        // then at the end of the shader the default MaterialBasicShader has
        // already read from the material's `map` texture (the depthTexture)
        // which has depth in 'r' and assigned it to gl_FragColor
        shader.fragmentShader = shader.fragmentShader.replace(
            '#include <common>',
            '#include <common>\n#include <packing>',
        ).replace(
            '#include <fog_fragment>',
            'gl_FragColor = packDepthToRGBA( gl_FragColor.r );',
        );
      };  
    
      const depthScene = new THREE.Scene();
      const depthPlane = new THREE.Mesh(planeGeo, depthMaterial);
      depthScene.position.set(0, 0, -1);
      depthScene.add(depthPlane);
    
      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }
    
      let depthValues = new Uint8Array(0);
      function render(time) {
        time *= 0.001;
    
        if (resizeRendererToDisplaySize(renderer)) {
          const canvas = renderer.domElement;
          renderTarget.setSize(canvas.width, canvas.height);
          depthRenderTarget.setSize(canvas.width, canvas.height);
          invisibleCamera.aspect = canvas.clientWidth / canvas.clientHeight;
          invisibleCamera.updateProjectionMatrix();
        }
    
        cameraPole.rotation.y = time * .1;
    
        // draw render target scene to render target
        renderer.setRenderTarget(renderTarget);
        renderer.clearDepth();
        renderer.render(invisibleScene, invisibleCamera);
        renderer.setRenderTarget(null);
        
        // render the depth texture to the canvas
        let cubeFaceCamera = cubeCamera.children[6];
        renderer.render(depthScene, cubeFaceCamera);
    
        requestAnimationFrame(render);
      }
    
      requestAnimationFrame(render);

      document.getElementById( 'capture' ).addEventListener( 'click', function( e ) {

          // // render the depth texture to another render target
          // let cubeFaceCamera = cubeCamera.children[renderedCubeCameraIndex];
          // renderer.setRenderTarget(depthRenderTarget);
          // renderer.clearColor();
          // renderer.render(depthScene, cubeFaceCamera);
          // renderer.setRenderTarget(null);

          // cubeCamera.position.copy( camera.position );
          cubeCamera.update( renderer, depthScene );

          // Unmanaged conversion. Do not use managed version since it will attempt a 
          // re-render. We previously, manually rendered every cube face ourselves already.
          // This manual rendering, face by face, to save the depth values, is necessary,
          // since the cube render target doesnt support depth textures.
          equi.convert( cubeCamera );
          // equi.update( cubeCamera, depthScene ); // managed
      });

      document.addEventListener('keydown', function(e) {
        if (e.keyCode >= 49 && e.keyCode < 55) {
          const invisibleCameraIndex = e.keyCode - 49;
          invisibleCamera = invisibleCubeCamera.children[invisibleCameraIndex];
        }
      });
    }
    
    main();
    </script>
</body>

</html>