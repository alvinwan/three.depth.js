<html>
    <head>
<style>
body {
    margin: 0;
  }
  #c {
    width: 100vw;
    height: 100vh;
    display: block;
  }
  #capture{
				position: absolute;
				left: 20px;
				top: 20px;
				padding: 10px;
				border: 1px solid white;
				z-index: 100;
				cursor: pointer;
				background-color: rgba( 0,0,0,.4);
			}
</style>
<script src="//cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://fake-vs-real-stereo.glitch.me/ocean.js"></script>
    <script src="js/CubemapToEquirectangular.js"></script>
    <script src="js/CubeOrthographicCamera.js"></script>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="capture" >Capture</div>

  <script>
    function main() {

      const canvas = document.querySelector('#c');
      const renderer = new THREE.WebGLRenderer({canvas});

      // Not used, but needed for the camera to be created. This is not used 
      // because depth textures on cube render targets are not supported. Instead,
      // we use the standard render target
      const notUsedCubeRenderTarget = new THREE.WebGLCubeRenderTarget(128);

      // Initialize a standard render target that can store depth textures for
      // usage later on.
      const invisibleRenderTarget = new THREE.WebGLRenderTarget(1, 1);
      invisibleRenderTarget.depthTexture = new THREE.DepthTexture();

      // Use a cube camera so that we don't need to manually initialize the 6 
      // perspective cameras needed for a cubemap.
      const invisibleFov = 90;
      const invisibleAspect = 1;
      const invisibleNear = 0.1;
      const invisibleFar = 100;
      const invisibleCubeCamera = new THREE.CubeCamera(invisibleNear, invisibleFar, notUsedCubeRenderTarget)
      invisibleCubeCamera.position.z = 1;

      // Choose the camera we'll by default render to the canvas.
      let canvasCameraIndex = 5;

      // Setup the scene that we'll use to render the depth values to a texture.
      const scenePackage = setupScene(invisibleCubeCamera);
      const invisibleScene = scenePackage.scene;
      const cameraPole = scenePackage.cameraPole;
    
      // depth render target will hold depth values from original scene in color 
      // channel. wont need the depth or stencil buffers for this color-only render
      // target
      const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024, {
        depthBuffer: false,
        stenciBuffer: false,
      });

      // Use orthographic cameras since we'll be rendering to flat "TV screen"
      // planes.
      const cubeCamera = new THREE.CubeOrthographicCamera(-1, 1, 1, -1, -1, 1, cubeRenderTarget);

      // Initialize the flat "TV screen" planes, which will hold the depth values 
      // as a color texture.
      const planeGeo = new THREE.PlaneBufferGeometry(2, 2);      
      const depthMaterial = new THREE.MeshBasicMaterial({
        map: invisibleRenderTarget.depthTexture,
      });
      depthMaterial.onBeforeCompile = function(shader) {
        // the <packing> GLSL chunk from three.js has the packDeathToRGBA function.
        // then at the end of the shader the default MaterialBasicShader has
        // already read from the material's `map` texture (the depthTexture)
        // which has depth in 'r' and assigned it to gl_FragColor
        shader.fragmentShader = shader.fragmentShader.replace(
            '#include <common>',
            '#include <common>\n#include <packing>',
        ).replace(
            '#include <fog_fragment>',
            'gl_FragColor = packDepthToRGBA( gl_FragColor.r );',
        );
      };  
    
      // Create a flat "TV screen" scene, to render the depth texture to.
      const depthScene = new THREE.Scene();
      const depthPlane = new THREE.Mesh(planeGeo, depthMaterial);
      depthScene.position.set(0, 0, -1);
      depthScene.add(depthPlane);
    
      // Animate the scene: rotate the camera around, render the depth at each
      // frame.
      function render(time) {
        time *= 0.001;

        let {invisibleCamera, depthScene} = getCameras(canvasCameraIndex);
    
        if (resizeRendererToDisplaySize(renderer)) {
          const canvas = renderer.domElement;
          invisibleRenderTarget.setSize(canvas.width, canvas.height);
          // depthRenderTarget.setSize(canvas.width, canvas.height); // how to resize cube render target?
          invisibleCamera.aspect = canvas.clientWidth / canvas.clientHeight;
          invisibleCamera.updateProjectionMatrix();
        }
    
        cameraPole.rotation.y = time * .1;
        renderDepthTo(null, canvasCameraIndex); // use null to specify canvas
    
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render); // begin animation

      // Setup cubemap to equirectangular conversion
      const equi = new CubemapToEquirectangular( renderer, false );

      /**
       * User Interaction
       */

      document.getElementById( 'capture' ).addEventListener( 'click', function( e ) {

          // render the depth texture to all faces of the cube, one at a time
          renderer.clearColor();
          for (let i = 0; i < 6; i++) {
            renderDepthTo(cubeRenderTarget, i);
          }

          // Unmanaged conversion. Do not use managed version since it will attempt 
          // a re-render. We previously manually rendered every cube face ourselves
          // already. This manual rendering, face by face, to save the depth values,
          // is necessary, since the *cube render target doesnt support depth textures.
          equi.convert( cubeCamera );
      });

      document.addEventListener('keydown', function(e) {
        if (e.keyCode >= 49 && e.keyCode < 55) {
          canvasCameraIndex = e.keyCode - 49;
        }
      });

      /**
       * Utilities
       */

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      function getCameras(cameraIndex) {
        // Select appropriate cameras given camera index
        let depthCamera = cubeCamera.children[cameraIndex]; // camera in depth space
        let invisibleCamera = invisibleCubeCamera.children[cameraIndex]; // camera in invisible space

        return {depthCamera, invisibleCamera};
      }

      function renderDepthTo(renderTarget, cameraIndex = 6) {
        let {depthCamera, invisibleCamera} = getCameras(cameraIndex);

        // draw render target scene to render target
        renderer.setRenderTarget(invisibleRenderTarget);
        renderer.render(invisibleScene, invisibleCamera);
        renderer.setRenderTarget(null);

        // set active cube face if the render target is a cube render target
        var activeCubeFace = renderTarget instanceof THREE.WebGLCubeRenderTarget ? cameraIndex : undefined;
        
        // render the depth texture to the provided target
        renderer.setRenderTarget(renderTarget, activeCubeFace);
        renderer.render(depthScene, depthCamera);
        renderer.setRenderTarget(null);
      }
    }

    function setupScene(camera) {
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('white');
      
        // put the camera on a pole (parent it to an object)
        // so we can spin the pole to move the camera around the scene
        const cameraPole = new THREE.Object3D();
        scene.add(cameraPole);
        cameraPole.add(camera);
      
        {
          const color = 0xFFFFFF;
          const intensity = 1;
          const light = new THREE.DirectionalLight(color, intensity);
          light.position.set(-1, 2, 4);
          scene.add(light);
        }
    
        const boxWidth = 1;
        const boxHeight = 1;
        const boxDepth = 1;
        const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
      
        function rand(min, max) {
          if (max === undefined) {
            max = min;
            min = 0;
          }
          return min + (max - min) * Math.random();
        }
      
        function randomColor() {
          return `hsl(${rand(360) | 0}, ${rand(50, 100) | 0}%, 50%)`;
        }
      
        const numObjects = 100;
        for (let i = 0; i < numObjects; ++i) {
          const material = new THREE.MeshPhongMaterial({
            color: randomColor(),
          });
      
          const cube = new THREE.Mesh(geometry, material);
          scene.add(cube);
      
          cube.position.set(rand(-20, 20), rand(-20, 20), rand(-20, 20));
          cube.rotation.set(rand(Math.PI), rand(Math.PI), 0);
          cube.scale.set(rand(3, 6), rand(3, 6), rand(3, 6));
        }

        return {scene, cameraPole};
      }
    
    main();
    </script>
</body>

</html>