<html>
  <head>
    <title>Export 360 Depth Map in Equirectangular</title>
    <style>
    body {
        margin: 0;
      }
    #c {
      width: 100vw;
      height: 100vh;
      display: block;
    }
    #capture{
      position: absolute;
      left: 20px;
      top: 20px;
      padding: 10px;
      border: 1px solid white;
      z-index: 100;
      cursor: pointer;
      background-color: rgba( 0,0,0,.4);
    }
    </style>
   <link href="../css/basic.css" rel="stylesheet">
   <script src="https://unpkg.com/three@0.125.1/build/three.min.js"></script>
   <script src="../js/WebGLDepthExporter.js"></script>
   <script src="../js/demo.js"></script>

    <script src="../js/CubemapToEquirectangular.js"></script>
    <script src="../js/WebGLCubeDepthExporter.js"></script>
  </head> 
  <body>
    <canvas id="c"></canvas>
    <div id="capture" >Capture</div>

    <div id="info">
			<a href="https://github.com/alvinwan/threejs.depth" target="_blank" rel="noopener">threejs.depth</a> webgl - depth texture<br/>
			Exports cubemap depth (1-6), downloads equirectangular depth (top-left button), toggle color (c).<br/>
      Created by <a href="http://twitter.com/lvinwan">@lvinwan</a>.
		</div>

    <script>
      const canvas = document.querySelector('#c');
      const renderer = new THREE.WebGLRenderer({canvas});

      // Initialize depth exporters
      const depthExporter = new THREE.WebGLDepthExporter(renderer);
      const cubeDepthExporter = new THREE.WebGLCubeDepthExporter(renderer, {
        maxPrecision: true
      });

      // Use a cube camera so that we don't need to manually initialize the 6 
      // perspective cameras needed for a cubemap.
      const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024);
      const cubeCamera = new THREE.CubeCamera(0.01, 10, cubeRenderTarget);
      let canvasCameraIndex = 5; // chose which cube face to render

      // Toggle color on and off
      let renderMode = 0; // 0 - depth, 1 - color
    
      // Setup and animate the scene
      let scene = setupTorusKnotScene();
      scene.add(cubeCamera);

      function render() {
        if (resizeRendererToDisplaySize(renderer)) { // handle resizing
          const canvas = renderer.domElement;
          setCubeCameraAspectRatio(cubeCamera, canvas.clientWidth / canvas.clientHeight);
          depthExporter.setSize(canvas.width, canvas.height);
          cubeDepthExporter.setSize(canvas.width, canvas.height);
          // cubeRenderTarget.setSize(canvas.width, canvas.height); // TODO: why makes erp blank?
        }
        cubeCamera.rotation.y += 0.01; // spin the camera around

        if (renderMode == 0) {
          // Render depth to the canvas
          depthExporter.setRenderTarget(null);
          depthExporter.render(scene, cubeCamera.children[canvasCameraIndex]);
        } else {
          renderer.setRenderTarget(null);
          renderer.render(scene, cubeCamera.children[canvasCameraIndex]);
        }
    
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render); // begin animation

      // Setup cubemap to equirectangular conversion
      const equi = new CubemapToEquirectangular( renderer, false );
      document.getElementById( 'capture' ).addEventListener( 'click', function( e ) {
          // Reset aspect ratio to 1. No idea why this is needed, but it is.
          var ratio = getCubeCameraAspectRatio(cubeCamera);
          setCubeCameraAspectRatio(cubeCamera, 1);

          // Render depth in all directions to a cubemap
          cubeDepthExporter.setRenderTarget(cubeRenderTarget);
          cubeDepthExporter.render(scene, cubeCamera);
          cubeDepthExporter.setRenderTarget(null);

          // Unmanaged conversion. Do not use managed version since it will attempt 
          // a re-render. We previously manually rendered every cube face ourselves
          // already. This manual rendering, face by face, to save the depth values,
          // is necessary, since the *cube render target doesnt support depth textures.
          equi.convert( cubeCamera );

          // Restore aspect ratio
          setCubeCameraAspectRatio(cubeCamera, ratio);
      });

      document.addEventListener('keydown', function(e) {
        if (e.keyCode >= 49 && e.keyCode < 55) {
          canvasCameraIndex = e.keyCode - 49;
        } else if (e.key == 'c') {
          renderMode = (renderMode + 1) % 2;
        }
      });

      /**
       * Utilities
       */

      function getCubeCameraAspectRatio(cubeCamera) {
        return cubeCamera.children[0].aspect;
      }

      function setCubeCameraAspectRatio(cubeCamera, aspect) {
        for (let camera of cubeCamera.children) {
          camera.aspect = aspect;
          camera.updateProjectionMatrix();
        }
      }

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }
    </script>
  </body>
</html>