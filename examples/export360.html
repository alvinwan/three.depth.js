<html>
  <head>
    <title>Export 360 Depth Map in Equirectangular</title>
    <style>
    body {
        margin: 0;
      }
    #c {
      width: 100vw;
      height: 100vh;
      display: block;
    }
    #capture{
      position: absolute;
      left: 20px;
      top: 20px;
      padding: 10px;
      border: 1px solid white;
      z-index: 100;
      cursor: pointer;
      background-color: rgba( 0,0,0,.4);
    }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"
            integrity="sha512-dLxUelApnYxpLt6K2iomGngnHO83iUvZytA3YjDUCjT0HDOHKXnVYdf3hU4JjM8uEhxf9nD1/ey98U3t2vZ0qQ=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"></script>
    <script src="../js/CubemapToEquirectangular.js"></script>
    <script src="../js/WebGLDepthExporter.js"></script>
    <script src="../js/WebGLCubeDepthExporter.js"></script>
  </head> 
  <body>
    <canvas id="c"></canvas>
    <div id="capture" >Capture</div>

    <script>
      function main() {

        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({canvas});

        // Initialize depth exporters
        const depthExporter = new THREE.WebGLDepthExporter(renderer);
        const cubeDepthExporter = new THREE.WebGLCubeDepthExporter(renderer);

        // Use a cube camera so that we don't need to manually initialize the 6 
        // perspective cameras needed for a cubemap.
        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024);
        const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRenderTarget);
        let canvasCameraIndex = 5; // chose which cube face to render
      
        // Setup and animate the scene
        const {scene, cameraPole} = setupScene(cubeCamera);
        function render(time) {
          time *= 0.001;
      
          if (resizeRendererToDisplaySize(renderer)) { // handle resizing
            const canvas = renderer.domElement;
            setCubeCameraAspectRatio(cubeCamera, canvas.clientWidth / canvas.clientHeight);
            depthExporter.setSize(canvas.width, canvas.height);
            cubeDepthExporter.setSize(canvas.width, canvas.height);
            // cubeRenderTarget.setSize(canvas.width, canvas.height); // TODO: why makes erp blank?
          }
          cameraPole.rotation.y = time * .1; // spin the camera around

          // Render depth to the canvas
          depthExporter.setRenderTarget(null);
          depthExporter.render(scene, cubeCamera.children[canvasCameraIndex]);
      
          requestAnimationFrame(render);
        }
        requestAnimationFrame(render); // begin animation

        // Setup cubemap to equirectangular conversion
        const equi = new CubemapToEquirectangular( renderer, false );
        document.getElementById( 'capture' ).addEventListener( 'click', function( e ) {
            // Reset aspect ratio to 1. No idea why this is needed, but it is.
            var ratio = getCubeCameraAspectRatio(cubeCamera);
            setCubeCameraAspectRatio(cubeCamera, 1);

            // Render depth in all directions to a cubemap
            cubeDepthExporter.setRenderTarget(cubeRenderTarget);
            cubeDepthExporter.render(scene, cubeCamera);
            cubeDepthExporter.setRenderTarget(null);

            // Unmanaged conversion. Do not use managed version since it will attempt 
            // a re-render. We previously manually rendered every cube face ourselves
            // already. This manual rendering, face by face, to save the depth values,
            // is necessary, since the *cube render target doesnt support depth textures.
            equi.convert( cubeCamera );

            // Restore aspect ratio
            setCubeCameraAspectRatio(cubeCamera, ratio);
        });

        document.addEventListener('keydown', function(e) {
          if (e.keyCode >= 49 && e.keyCode < 55) {
            canvasCameraIndex = e.keyCode - 49;
          }
        });

        /**
         * Utilities
         */

        function getCubeCameraAspectRatio(cubeCamera) {
          return cubeCamera.children[0].aspect;
        }

        function setCubeCameraAspectRatio(cubeCamera, aspect) {
          for (let camera of cubeCamera.children) {
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
          }
        }

        function resizeRendererToDisplaySize(renderer) {
          const canvas = renderer.domElement;
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          const needResize = canvas.width !== width || canvas.height !== height;
          if (needResize) {
            renderer.setSize(width, height, false);
          }
          return needResize;
        }
      }

      function setupScene(camera) {
          const scene = new THREE.Scene();
          scene.background = new THREE.Color('white');
        
          // put the camera on a pole (parent it to an object)
          // so we can spin the pole to move the camera around the scene
          const cameraPole = new THREE.Object3D();
          scene.add(cameraPole);
          cameraPole.add(camera);
        
          {
            const color = 0xFFFFFF;
            const intensity = 1;
            const light = new THREE.DirectionalLight(color, intensity);
            light.position.set(-1, 2, 4);
            scene.add(light);
          }
      
          const boxWidth = 1;
          const boxHeight = 1;
          const boxDepth = 1;
          const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
        
          function rand(min, max) {
            if (max === undefined) {
              max = min;
              min = 0;
            }
            return min + (max - min) * Math.random();
          }
        
          function randomColor() {
            return `hsl(${rand(360) | 0}, ${rand(50, 100) | 0}%, 50%)`;
          }
        
          const numObjects = 100;
          for (let i = 0; i < numObjects; ++i) {
            const material = new THREE.MeshPhongMaterial({
              color: randomColor(),
            });
        
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
        
            cube.position.set(rand(-20, 20), rand(-20, 20), rand(-20, 20));
            cube.rotation.set(rand(Math.PI), rand(Math.PI), 0);
            cube.scale.set(rand(3, 6), rand(3, 6), rand(3, 6));
          }

          return {scene, cameraPole};
        }
      
      main();
    </script>
  </body>
</html>